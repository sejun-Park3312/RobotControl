Index: ClassFiles/Control.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\nimport math\nimport numpy as np\nfrom ProjectPath import PROJECT_PATH\nfrom simple_pid import PID\nfrom ClassFiles.BasicMagnetFuns import BasicMagnetFuns\n\nclass Control:\n    def __init__(self):\n        print(\"Controller Initializing...\")\n        # Basic Magnet Functions\n        self.BF = BasicMagnetFuns()\n\n        # Distance Offsets\n        self.Z_Reference = 80 / 1000 # system(센터 코일 높이)과 Target 사이 Reference 거리\n        self.Z_System = 70/1000 # system 높이(World 좌표계 기준)\n        self.Z_Target = 0 # Target 높이(World 좌표계 기준)\n\n        # Array\n        self.C_Points, self.C_Angles, self.M_Points, self.M_Angles = self.Array()\n\n        # DipoleMoment Magnitude\n        self.Ms = 2\n        self.Mc = 0.92 # NA\n        self.Mt = 0.0265\n\n        # Mechanical Properties\n        self.F_Buoyance = 0.005146777750500\n        self.Weight = 0.006776951342543\n        self.I_Max = 1.5\n        self.alpha = 1\n\n        # PID\n        self.SamplingTime = 25 / 1000\n        self.Kp =1e-1/2\n        self.Kd = 1e-2\n        self.Ki = 0\n        self.pid = PID(Kp=self.Kp, Kd=self.Kd, Ki=self.Ki, setpoint = 0)\n        self.pid.sample_time = self.SamplingTime\n\n        print(\"Controller Ready!\")\n        print(\"\")\n        print(\"\")\n\n\n\n    def Array(self):\n        # Coil/Magent Array\n        Data = np.load(\"../Data/Array_Data/Data.npz\")\n        C_Points = Data['C_Points']\n        C_Angles = Data['C_Angles']\n        M_Points = Data['M_Points']\n        M_Angles = Data['M_Angles']\n\n        C_Points[:,2] = 0\n        M_Points[:,2] = 0\n        return C_Points, C_Angles, M_Points, M_Angles\n\n\n    def Angle2Direction(self, Angle):\n        Direction = np.array([math.sin(Angle[1]) * math.cos(Angle[0]), math.sin(Angle[1]) * math.sin(Angle[0]), math.cos(Angle[1])])\n        return Direction\n\n\n    def MagnetArray_Force(self):\n        m_target = np.array([1, 0, 0]) * self.Mt\n        F = np.array([[0], [0], [0]])\n        for i in range(self.M_Points.shape[0]):\n            m_source = self.Angle2Direction(self.M_Angles[i, :]) * self.Ms\n            # World 좌표계 기준\n            r_source2target = np.array([[0, 0, self.Z_Target]]) - (self.M_Points[i, :] + np.array([0, 0, self.Z_System + 40/1000]))\n            F = F + self.BF.Cal_MagnetForce(r_source2target, m_source, m_target)\n\n        Fz = F[2]\n        return Fz\n\n\n    def CoilArray_ACoeff(self):\n        m_target = np.array([1, 0, 0]) * self.Mt\n        A_vec = np.array([[0], [0], [0]])\n        for i in range(self.C_Points.shape[0]):\n            m_source_i = self.Angle2Direction(self.C_Angles[i, :]) * self.Mc\n            # World 좌표계 기준\n            r_source2target = np.array([[0, 0, self.Z_Target]]) - (self.C_Points[i, :] + np.array([0, 0, self.Z_System]))\n            A_vec = A_vec + self.BF.Cal_MagnetForce(r_source2target, m_source_i, m_target)\n\n        Az_Coeff = A_vec[2]\n        return Az_Coeff\n\n\n    def Get_PWM(self):\n        Z_Error = self.Z_Reference - (self.Z_System - self.Z_Target)\n        F_pid = self.pid(Z_Error, dt = self.SamplingTime)\n        I = (F_pid - self.MagnetArray_Force() + self.alpha * (- self.F_Buoyance + self.Weight)) / self.CoilArray_ACoeff()\n        PWM = round(float(np.clip(I, 0, self.I_Max) * 255 / self.I_Max))\n        return PWM\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ClassFiles/Control.py b/ClassFiles/Control.py
--- a/ClassFiles/Control.py	(revision 9ab93f77fe9d54eab360d3198d4640c7b68c3db3)
+++ b/ClassFiles/Control.py	(date 1754471117493)
@@ -12,7 +12,7 @@
         self.BF = BasicMagnetFuns()
 
         # Distance Offsets
-        self.Z_Reference = 80 / 1000 # system(센터 코일 높이)과 Target 사이 Reference 거리
+        self.Z_Reference = 70 / 1000 # system(센터 코일 높이)과 Target 사이 Reference 거리
         self.Z_System = 70/1000 # system 높이(World 좌표계 기준)
         self.Z_Target = 0 # Target 높이(World 좌표계 기준)
 
